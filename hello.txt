啊啊啊啊啊啊啊啊我真的没有违规
真的是进不去githu、
我草泥马历经千辛万苦终于进来了 妈蛋
老李再和你对话  github！！！


如何解决failed to push some refs to git
错误的主要原因是github中的README.md文件不在本地代码目录中
git pull --rebase origin master  (pull=fetch+merge)
git push -u origin master
hahaha
练习笔记


1.优先队列
  例子：医院急诊室  登机顺序
      实现一个优先级队列：两个选项：设置优先级，在正确的位置添加元素
                       元素的添加与删除是基于优先级
      使用api：array的findIndex：按条件找到满足条件第一个元素下标返回  返回-1代表没找到
              array的splice向数组的一个位置添加或者删除一个元素
              array的shift：删除数组的第一个元素并返回该元素
              array的push：向数组尾部添加一个元素
      复习：定义类的方法 若返回类相关属性的值  需要在方法前加get
 2.循环队列
    目的：充分利用向量空间，克服“假溢出”，将向量空间看作首尾相接圆环，这种向量称为循环向量，存储在
        在其中的队列称为循环队列（circular  queue） 、
    实现：单链表  队列
    特点，整个队列是一个环形 索引元素时下标超出会从队列头开始继续寻找  利用取余的方法
  3.链表
    解决前者的缺点{
     1：数组大小固定
     2：起点或中间插入或移除成本很高（要移动元素）
    }
    闪亮登场：链表 在内存中不是连续存放
    特征：一个元素由 1：存储元素本身节点2：指向下一个元素的引用（指针）
    head ---》 node：{item，next} --> node：{item，next} -> null
    优点：添加 移除元素时不需要移动其他元素 但要使用指针
    缺点：以数组为底层的栈stack 和队列 queue 可以直接访问任何位置元素、链表不可以 要从表头开始迭代列表知道找到所需元

    例子：火车
    程序：分别需要1.链表 与2.节点两个类 无论删除还是添加或插入都要从head开始
          用current代表当前元素指针，previous代表上一个 一般插入时使用
          在特定位置插入需要判断是否越界
   4.双向链表
     新特点：两种迭代方法 从头到尾或者反过来 可访问一个节点的{前一个}或{后一个元素}
     单向链表缺点：错过要找的元素要返回起点重新迭代
     优点：解决如上单向链表缺点
     head--》 node{prev，item，next}--->node{prev,item,next(tail)}--->null
     null<---
     问题：写起来比较麻烦 需要多考虑一个指针prev  删除和插入时要考虑首尾两指针
   5，循环链表：tail指向head而不是null 无prev指针
   6.集合
     特点：集合内元素无序且唯一  用{}包围 与对象和枚举对比记忆
     目前ES6已经新加入了set类型的实现



